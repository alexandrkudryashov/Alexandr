/*
Скретч проекта универсального 8 канального суточного таймера.

Возможности:
 * 4 канала с суточными таймерами (до 10 таймеров вкл/выкл на каждый канал) привязаны к реальному времени.
 * 4 канала с периодическими таймерами (настройки: период работы (Period)чч:мм и длительность (Duration)чч:мм) НЕ привязаны к реальному времени, интервал от 1 минуты до 99 часов 99 минут.
 * сохранение настроек при отключении питания.
 * возобновление работы суточных таймеров при подаче питания в то состояние в котором должны находиться реле относительно текущего времени согласно расписания.
 * возможность установки/корректировки времени.
 * быстрое восстановление настроек по умолчанию в случае необходимости.
 * возможность оперативного ручного включения/отключения любых каналов независимо от текущего расписания работы.
 * 
В работе над проектом использованы библиотеки и материалы с сайтов AlexGyver http://AlexGyver.ru/, и https://iarduino.ru/, за что им огоромное спасибо!

Автор: AMatroskin,  2020 год.
https://cxem.net/profile/22479
 */

#define BTN1 14  //_____________________Пины кнопок
#define BTN2 15
#define BTN3 16
#define CLK 2   //______________________Пины энкодера
#define DT 3
#define SW 4
#define BINARY_ALGORITHM

#include <EEPROM.h> //__________________Библиотеки 
#include "GyverEncoder.h"
#include <GyverButton.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <iarduino_RTC.h>

Encoder enc1(CLK, DT, SW); //__________Объекты (энкодер, LCD, RTC таймер, кнопки)
LiquidCrystal_I2C lcd(0x27, 16, 2);//__Часы и дисплей подключены по I2C (пины A4 и A5, SDA и SCL соответсвенно)
iarduino_RTC watch(RTC_DS1307);
GButton butt1(BTN1);
GButton butt2(BTN2);
GButton butt3(BTN3);

bool state1 = 0;  //_________________Переменные состояния каналов(вкл/выкл)
bool state2 = 0;
bool state3 = 0;
bool state4 = 0;
bool state5 = 0;
bool state6 = 0;
bool state7 = 0;
bool state8 = 0;

bool flag = 1; //____________________Флаг для однократного срабатывания таймера простоя

uint8_t h_set = 0;//_________________Переменные используемые при установке (корректировке)времени
uint8_t m_set = 0;
uint8_t s_set = 0;

uint16_t current_time = 0 ; //_______Текущее время в минутах (для основных расчетов)

uint32_t counter1 = 0; //____________Счетчики для периодических каналов
uint32_t counter2 = 0;
uint32_t counter3 = 0;
uint32_t counter4 = 0;

uint32_t period_wait = 60000;  //______________________________Период простоя в мс отсчитывается после последнего нажатия на кнопку, по истечении переключается на главный экран и отключает подсветку
uint32_t period_cur = 0;     //________________________________Переменная для отсчета простоя

uint8_t number_channel = 0;  //________________________________Номер активного канала
uint8_t time_num;            //________________________________Переменная порядкового номера элемента в массиве

const char* strM = "JanFebMarAprMayJunJulAugSepOctNovDec";  // Определяем массив всех вариантов текстового представления текущего месяца находящегося в предопределенном макросе __DATE__.
const char* sysT = __TIME__;                                // Получаем время компиляции скетча в формате "SS:MM:HH".
const char* sysD = __DATE__;                                // Получаем дату  компиляции скетча в формате "MMM:DD:YYYY", где МММ - текстовое представление текущего месяца, например: Jul.
//  Парсим полученные значения в массив:                    // Определяем массив «i» из 6 элементов типа int, содержащий следующие значения: секунды, минуты, часы, день, месяц и год компиляции скетча.
const int i[6] {(sysT[6] - 48) * 10 + (sysT[7] - 48), (sysT[3] - 48) * 10 + (sysT[4] - 48), (sysT[0] - 48) * 10 + (sysT[1] - 48), (sysD[4] - 48) * 10 + (sysD[5] - 48), ((int)memmem(strM, 36, sysD, 3) + 3 - (int)&strM[0]) / 3, (sysD[9] - 48) * 10 + (sysD[10] - 48)};

//____номера элементов__0,_1,____2,____3,____4,____5,____6,____7,____8,____9,____10,___11,___12,___13,___14,___15,___16,___17,___18,___19,___20
//_____________________st____on/off______on/off_____ и т.д..
uint16_t Timer1 [21] = {0, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440}; // массивы всех таймеров для суточных каналов (1 - 4) 0-й элемент отвечает за состояние канала (1 - вкл/ 0 - выкл/ 2 - авто))
uint16_t Timer2 [21] = {0, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440}; // остальные время в минутах (нечетные элементы - таймеры включения, четные - выключения)
uint16_t Timer3 [21] = {0, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440}; // время 1440 отображается на экране как "--:--", это нективное значение, для основной логики пустая ячейка, означает что таймер не задан
uint16_t Timer4 [21] = {0, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440, 1440}; // 1440 минуты  нет в сутках ( по факту это 1441 минута, т.к. счет идет с нулевой минуты, т.е. 1439 + нулевая минута)

uint32_t Timer5 [3] = {0, 0, 0};  //____________________________массив всех таймеров для периодических каналов (5 - 8) 0-й элемент отвечает за состояние канала (1 - вкл/ 0 - выкл/ 2 - авто))
uint32_t Timer6 [3] = {0, 0, 0};  //____________________________1й элемент - период, 2й - длительность (значение в милисекундах)
uint32_t Timer7 [3] = {0, 0, 0};
uint32_t Timer8 [3] = {0, 0, 0};
